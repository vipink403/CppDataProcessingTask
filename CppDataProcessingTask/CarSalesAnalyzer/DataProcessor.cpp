#include "DataProcessor.h"
#include <fstream>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <string_view>

// ============================================================================
// UTILITY FUNCTIONS - CSV PARSING
// ============================================================================

// Extract next comma-separated token from a string_view
// Modifies the string_view to point past the extracted token
// Returns the extracted token as a string_view
inline std::string_view next_token(std::string_view& sv)
{
	size_t pos = sv.find(',');
	if (pos == std::string_view::npos) {
		// No more commas; return entire remaining string
		auto token = sv;
		sv.remove_prefix(sv.size());
		return token;
	}
	// Extract token up to comma and advance pointer
	auto token = sv.substr(0, pos);
	sv.remove_prefix(pos + 1);
	return token;
}

// Parse the CSV header line and build a map of column names to indices
// Returns a ColumnIndices struct with the position of each required column
ColumnIndices buildColumnIndices(const std::string& headerLine)
{
	std::unordered_map<std::string, int> colIndex;
	int idx = 0;
	std::string_view sv(headerLine);

	// Extract all column names and their positions
	while (!sv.empty())
	{
		auto col = next_token(sv);
		colIndex[std::string(col)] = idx++;
	}

	// Return struct with indices for each required column
	return ColumnIndices{
		colIndex.at("sale_date"),
		colIndex.at("country"),
		colIndex.at("manufacturer"),
		colIndex.at("condition"),
		colIndex.at("sale_price_usd"),
		colIndex.at("region")
	};
}

// Parse a single CSV line into a SaleRecord using the column indices
// Only extracts columns up to the maximum required index for efficiency
SaleRecord parseLine(const std::string& line, const ColumnIndices& indices)
{
	SaleRecord record{};
	std::string_view sv(line);
	int column = 0;
	int maxIdx = std::max({ indices.sale_date, indices.country, indices.manufacturer, 
	                         indices.condition, indices.sale_price_usd, indices.region });

	while (column <= maxIdx && !sv.empty())
	{
		auto token = next_token(sv);

		// Map each column to the corresponding SaleRecord field
		if (column == indices.sale_date) {
			record.sale_date = std::string(token);
		}
		else if (column == indices.country) {
			record.country = std::string(token);
		}
		else if (column == indices.region) {
			record.region = std::string(token);
		}
		else if (column == indices.manufacturer) {
			record.manufacturer = std::string(token);
		}
		else if (column == indices.condition) {
			record.condition = std::string(token);
		}
		else if (column == indices.sale_price_usd) {
			record.sale_price_usd = std::stold(std::string(token));
		}
		++column;
	}

	return record;
}

// ============================================================================
// DATA EXTRACTION FUNCTIONS
// ============================================================================

// Extract year from date string (assumes YYYY-MM-DD format)
// Returns -1 if parsing fails
int extractYear(const std::string& dateStr) 
{ 
	try 
	{ 
		return std::stoi(dateStr.substr(0, 4)); 
	} 
	catch (...) 
	{ 
		return -1; 
	} 
}

// Count new and used Audi cars sold in a specific year and country
// Returns a pair: {newCarCount, usedCarCount}
pll countAudiCarsSoldInYear(const std::string& filename, int targetYear, const std::string& brand, const std::string& country)
{
	std::ifstream file(filename);
	if (!file.is_open()) {
		std::cerr << "Error: Could not open file " << filename << std::endl;
		return { -1,-1 };
	}

	std::string headerLine;
	std::getline(file, headerLine);
	ColumnIndices indices = buildColumnIndices(headerLine);

	long long audiNewCarCount = 0, audiUsedCarCount = 0;
	std::string line;

	// Count cars matching all criteria: brand, country, year, and condition
	while (std::getline(file, line))
	{
		SaleRecord record = parseLine(line, indices);

		int year = extractYear(record.sale_date);
		if (year == targetYear && record.manufacturer == brand && record.country == country) 
		{
			if(record.condition == "New")
				audiNewCarCount++;
			else
				audiUsedCarCount++;
		}
	}

	file.close();
	return { audiNewCarCount, audiUsedCarCount };
}

// Calculate total revenue generated by a specific manufacturer across all regions and years
long long totalRevenueGeneratedByBMW(const std::string& filename, const std::string& brand)
{
	std::ifstream file(filename);
	if (!file.is_open()) {
		std::cerr << "Error: Could not open file " << filename << std::endl;
		return -1;
	}

	std::string headerLine;
	std::getline(file, headerLine);
	ColumnIndices indices = buildColumnIndices(headerLine);

	long long totalRevenue = 0;
	std::string line;
	
	// Sum revenue for all records matching the specified manufacturer
	while (std::getline(file, line))
	{
		SaleRecord record = parseLine(line, indices);

		if (record.manufacturer == brand)
		{
			totalRevenue += static_cast<long long>(record.sale_price_usd);
		}
	}

	file.close();
	return totalRevenue;
}

// Build a map of country -> total revenue for a specific manufacturer in a specific region
void revenueDistributionOfBMWInEurope(const std::string& filename, const std::string& brand, std::map<std::string, long long>& regionRevenue)
{
	std::ifstream file(filename);
	if (!file.is_open()) {
		std::cerr << "Error: Could not open file " << filename << std::endl;
		return;
	}

	std::string headerLine;
	std::getline(file, headerLine);
	ColumnIndices indices = buildColumnIndices(headerLine);

	std::string line;
	
	// Accumulate revenue by country for manufacturer in specified region
	while (std::getline(file, line))
	{
		SaleRecord record = parseLine(line, indices);

		if (record.manufacturer == brand && record.region == "Europe")
		{
			regionRevenue[record.country] += static_cast<long long>(record.sale_price_usd);
		}
	}

	file.close();
}

// ============================================================================
// DISPLAY FUNCTIONS
// ============================================================================

// Display first N records from the CSV file (for verification/testing)
void displaySampleRecords(const std::string& filename, int maxRecords)
{
	std::ifstream file(filename);
	if (!file.is_open()) {
		std::cerr << "Error: Could not open file " << filename << std::endl;
		return;
	}

	std::string headerLine;
	std::getline(file, headerLine);
	ColumnIndices indices = buildColumnIndices(headerLine);

	std::string line;
	int recordCount = 0;

	std::cout << "\n--- Sample Records ---\n";
	while (std::getline(file, line) && recordCount < maxRecords)
	{
		SaleRecord record = parseLine(line, indices);
		std::cout << "Date: " << record.sale_date << " | Manufacturer: " << record.manufacturer
			<< " | Country: " << record.country << " | Price: $" << record.sale_price_usd << "\n";
		recordCount++;
	}

	file.close();
}

// ============================================================================
// MULTI-QUERY FUNCTION - SINGLE PASS OPTIMIZATION
// ============================================================================

// Compute multiple aggregates in a single pass through the file
// This is more efficient than calling separate functions that each read the file
// Calculates:
//   1. Audi cars sold in China in 2025 (new vs used)
//   2. Total BMW revenue in 2025
//   3. BMW revenue distribution across European countries
void ComputeEverythingInSinglePass(const std::string& filename, std::map<std::string, long long>& regionRevenue)
{
	std::ifstream file(filename);
	if (!file.is_open()) {
		std::cerr << "Error: Could not open file " << filename << std::endl;
		return;
	}

	std::string headerLine;
	std::getline(file, headerLine);
	ColumnIndices indices = buildColumnIndices(headerLine);

	// Accumulators for different metrics
	long long audiNewCarSoldInChina = 0, audiUsedCarSoldInChina = 0;
	long long totalBMWRevenue = 0;

	std::string line;

	// Single pass through entire file
	while (std::getline(file, line))
	{
		SaleRecord record = parseLine(line, indices);

		int year = extractYear(record.sale_date);
		
		// Check for Audi cars in China in 2025
		if (record.manufacturer == "Audi" && record.country == "China" && year == 2025)
		{
			if (record.condition == "New")
				audiNewCarSoldInChina++;
			else
				audiUsedCarSoldInChina++;
		}
		// Check for BMW records (multiple conditions)
		else if (record.manufacturer == "BMW")
		{
			// Sum BMW revenue for 2025
			if(year == 2025)
				totalBMWRevenue += static_cast<long long>(record.sale_price_usd);
			
			// Also accumulate BMW revenue by country in Europe
			if (record.region == "Europe")
			{
				regionRevenue[record.country] += static_cast<long long>(record.sale_price_usd);
			}
		}
	}

	file.close();

	// Display Audi results
	std::cout << "\n--- Results from Single Pass ---\n";
	std::cout << "Number of New Audi cars sold in 2025 in China: " << audiNewCarSoldInChina << std::endl;
	std::cout << "Number of Used Audi cars sold in 2025 in China: " << audiUsedCarSoldInChina << std::endl;
	std::cout << "Total Number of Audi cars sold in 2025 in China: " << (audiNewCarSoldInChina + audiUsedCarSoldInChina) << std::endl;
	
	// Display BMW total revenue
	std::cout << "Total revenue generated by BMW in 2025: $" << totalBMWRevenue << std::endl;

	// Sort BMW European revenue by country (descending order)
	std::vector<std::pair<std::string, long long>> sortedRevenue(regionRevenue.begin(), regionRevenue.end());
	std::sort(sortedRevenue.begin(), sortedRevenue.end(),
		[](const std::pair<std::string, long long>& lhs, const std::pair<std::string, long long>& rhs)
		{
			return lhs.second > rhs.second;  // Sort descending by revenue
		}
	);
	
	// Display BMW revenue distribution in Europe
	std::cout << "\nBMW Revenue distribution in Europe (highest to lowest):\n";
	for (const auto& pr : sortedRevenue)
	{
		std::cout << "Total revenue in " << pr.first << ": $" << pr.second << std::endl;
	}
}

